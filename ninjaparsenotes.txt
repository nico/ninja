ninja with a "return 1" after manifest parsing:
0.26s

ninja with a "return 1" after manifest parsing, with llvm's StringMap:
0.248s

ninja with a "return 1" after manifest parsing and ParseEdge() and other code
that builds DOM commented out (same with llvm's StringMap):
0.091s

bench0.py:
0.168s (subninja)
0.128s (scope file)

bench0.c
0.023s (subninja)

bench0_sse.c
0.015s (subninja)

bench0_sse_tok.cc
0.027s (subninja) (static 2.4MiB buf)
0.024s (scope file) (dynamic 15 MB buf)

malloc'd 15 MB buf, all freed:
0.206s (subninja)

malloc'd 3 MB buf, all freed:
0.026s (subninja)

calloc'd 3 MB buf, all freed:
0.130s (subninja)

calloc'd 15 MB buf, all freed:
3.614s (subninja)  (!!)

malloc'd correctly-sized buffers:
0.027s

ReadFile() with appending string:
0.029s

ReadFile() with appending string, reserve() with right size
0.030s


(perf issue: forgot to 0-terminate input, and parser looked for 0. not an
issue with just one file, but subninjas were reusing the stack-allocated buffer
so that ended being 0.)


With StringMap for every Identifer:
0.058s

With StringMap and Identifer-based "subninja" / "include" detection:
0.056s

With MallocAllocator instead of BumpPtrAllocator:
0.068s

(changing the BumpPtrAllocator from 2k to 64k doesn't affect things)

With on-demand shared cleaning:
0.075s D:

With during-parsing non-shared cleaning (makes variables trickier?):
0.065s


With map<II*, II*> for every edge and rule:
0.058s (compared to 0.055s without it). Can probably be more efficient; maybe
not needed though.


chrome evalstring stats:
56833 clean (just strings)
13064 cleaned (contain $$, etc), 7510 of those are unique
1521 vars (contain var refs)
  only 8 of those are unique! (because I don't eval commands atm)
                              (most of them in different scopes though)
With counting in LexEvalString:
1662 vars (111 computed) So only 10% have unique parse structure at least.

133780 read in total, so there are a bunch Evaluate() isn't called on yet :-/
(with forced eager CleanedUp in LexEvalString:
175140 clean, 26875 cleaned (8257 computed), 1662 vars
So most of the missed ones are clean, so doesn't matter much either way.)

#cached @size
0      16kB
1       8kB
1       4kB
673     2kB

llvm evalstring stats:
16847 clean, 2 cleaned (1 computed), 0 vars
  The 1 computed is for an escaped space. long string, around twice.

LexEvalString for counting vars:
42 vars (28 computed)



chrome: read 13233 kB, 785 files
  just reading: 0.015s -> 882 MB/s
  bench: 0.058s -> 228.15 MB/s
  bench/clean: 0.074s -> 178.8 MB/s
  bench/inlineclean: 0.064s -> 206.76 MB/s
  ninja: 0.265s -> 49.93 MB/s
llvm: read 3543 kB, 2 files
  bench: 0.015s -> 236.2 MB/s
  ninja: 0.066s -> 53.68 MB/s
  clang: 0.077ms -> 46 MB/s
    time clang -x c -E ~/src/llvm-build/build.ninja   > /dev/null
      (with s/[#'"]/./g)



Plan for lexing:
- LexIdentifier() slurps everything non-whitespace non-$
- On $, goes down special path, writes 'needs cleanup', 'has var' flags
- Token has an IdentifierInfo, which is an entry in the Identifiers hash table
- hash table owns the storage of IdentifierInfos (i.e. strings are copied from
  file buffer to hash table once)
- IdentifierInfo has flags if they contain variables, if not they are
  canonicalized only once -- hopefully cuts down on CanonPath calls a lot
- Hash table maps canonicalized and regular path to same IdentifierInfo (?)
- non-variable-$ cleanups are done when copying string into the hash table,
  maybe as part of canonicalizing? (but then the hash table won't save any
  CanonPath() calls)

Stuff left:
- implement variable substitution
- measure win from doing this only when needed
- implement canonicalization
- measure win from only doing this once per identifierinfo
- build graph (rules, edges, nodes)
- measure win from bumpptrallocating graph


StringMap:
- array of pointers to entries, followed by array of hash values
- entry is strlen, value data, key data (allocated from a bumpptr allocator,
  optionally)
- due to bumpptr allocator, most hash entries will be next to each other
- quadratic probing
